**Ресурсы**: процессорное время, память, устройства ввода-вывода.  

#Ядро  
**Занимается** управлением процессами и ресурсами.   
**Работает с**:
* Процессы
* Файлы
* События
* Потоки
* Семафоры


# Процессы
## Что такое процесс 
Выполняющаяся программа   
**С процессом связаны:**
* Адресное пространство (участок памяти, откуда можно считывать и куда записывать)
    * Исполняемая программа
    * Её данные и стек
* Ресурсы
* Список связанных процессов

## Создание процесса
**Создание процесса** может происходить при:  
* Запуске ОС
* Запросе на создание процесса (уже работающий процесс выполняет системный вызов)  

**Системный вызов** - обращение процесса к ядру операционной системы для выполнения какой-либо операции.  

## Жизнь процесса
### Реализация процесса
Информация о процессах хранится в **таблице процессов**, а именно:     
* Состояние процесса
* Счётчик команд
* Указатель стека
* Распределение памяти
* И другое
  
Системные вызовы, используемые при управлении процессами:
* Создание
* Завершение  
  
Если процесс способен создать другие процессы (**дочерние**), то говорят о **дереве процессов**. Связанные процессы могут нуждаться в обмене информацией и синхронизации, то есть в **межпроцессорном взаимодействии**.  
  
Другие процессные системные вызовы:
* Запрос дополнительной памяти
* Ожидание завершения дочернего процесса
* Загрузка другой программы поверх своей  

### Состояния процесса:
* Выполняемый
* Готовый (не выполняется по внешним причинам - нет свободного процессорного времени)
* Заблокированный (не выполняется по внутренним причинам - нет необходимой для его выполнения информации)   

![](https://pp.vk.me/c836126/v836126501/19ecf/DmPysmfP15M.jpg)  
Переходы осуществляются:  
* _1_ и _4_ - самой ОС
* _2_ и _3_ - **планировщиком процессов**  

Если процесс приостанавливается, позже он должен быть возобновлён в том же состоянии.  
    
## Смерть процесса  
* Обычное завершение
* Выход по ошибке
* Выход по фатальной ошибке
* Уничтожение другим процессом  

## Потоки
Как бы **подпроцессы**, существующие в рамках какого-либо процесса.   
Внутри процесса потоки обладают общим **адресным пространством**, но у каждого потока есть свой стек для процедур и счётчик команд.  
Потоки это хорошо. Переключение между потоками происходит подобно тому, как это делается в процессах.

## Взаимодействие и состязание процессов
Три проблемы:  
* Работа процессов без помех друг другу
* Пересылка сообщений
* Обработка процессов, ожидающих инфу от других процессов  

**Прерывание** — сигнал от программного или аппаратного обеспечения, требующий внимания  
### Работа процессов без помех друг другу
* Запрет на одновременное исполнение критических областей более чем одним процессом
    * Перед входом в критическую область процесс проверяет разрешён ли этот вход. Если нет, то простой. 
    * Атомарные `up` и `down` с семафорами.

**Критическая область** - часть программы, использующая доступ к общей памяти.  
**Семафор** - количество отложенных активизаций  
**Атомарное действие** - неделимое действие, которое не может быть прервано, либо выполняется целиком либо не выполняется вовсе.  

## Планирование
### Общие сведения
Политика предоставления процессорного времени двум и более готовым процессам.  
Выделяют процессы, ограниченные скоростью:
* Вычислений (мало простоев, много активности)
* Работы устройств I/O (много простоев, мало активности) - сейчас самая распространённая ситуация  

Моменты принятия решения планировщиком: когда:
* Создаётся дочерний процесс (выполнять родительский или дочерний)
* Процесс завершает работу
* Процесс блокируется
* Происходит выход из прерывания  

Алгоритмы планирования:
* Неприоритетный (выполняется, пока не: заблокируется, уйдёт сам, будет убит кем-то)
* Приоритетный (всё тоже, но плюс прерывание по таймеру, то есть процессу выделяется какое-то время)  

Среды планирования:
* Пакетная (долгие процессы, мало переключений, неприоритетный алгоритм)
* Интерактивная (короткие процессы, много переключений, приоритетный алгоритм)
* Реального времени (короткие процессы, много переключений, неприоритетный алгоритм)  

Задачи планирования:
* Все системы:
 * Равнодоступность - каждому процессу справедливую долю процессорного времени
 * Определённая политика
 * Баланс - поддержка системы загруженной
* Пакетные:
 * Производительность - максимальное кол-во заданий в час
 * Оборотное время - минимизация среднего времени ответа на запрос
* Интерактивные:
 * Время отклика - быстрый ответ
* Реального времени:
 * Соблюдение предельных сроков


### Для пакетных систем
* FIFO
* Сначала самое короткое задание (по общему времени)
* Сначала самое короткое задание (по оставшемуся времени)


### Для интерактивных систем
* Циклическое планирование - каждому процессу выделяется интервал времени (**квант**). Оптимальное значение 20-50 мс.
* Приоритетное планирование - каждому процессу присваивается приоритет. Чтобы избежать постоянного выполнения только приоритетных процессов, после истечения кванта выполнения процесса, его приоритет снижается, и на первый план выходят процессы ниже приоритетами.  
Приоритеты могут присваивается **статически** и **динамически**.  
**Статически** - распределение приоритетов во каким-то внешним критериям (генералам наивысший, полковникам средний, солдатам низший)  
**Динамически** - по внутренним причинами (как только процесс, ждавший ответа от HDD получает его, он тут же должен получить процессорное время)  
Также существует **группировка процессов по приоритетам**. То есть приоритетному планированию подчиняются **группы**, а внутри них применяется циклическое планирование
* Несколько очередей - используется описанная выше **группировка процессов по приоритетам**, только ещё более нижним группам выделяются большие кванты времени
* Выбор самого короткого процесса
* Гарантированное планирование - раздача обещаний, что при `n` процессах в ожидании, вы получите `1/n` процессорной мощности.
* Лотерейное планирование
 
> Все процессы равны, но некоторые равнее  

Проводятся розыгрыши процессорного времени. Например 50 раз в секунду разыгрываются 20 мс процессорного времени.  
* Справедливое планирование - при распределении учитывается, кто владелец процесса, чтобы не было чрезмерных перекосов.

### Для систем реального времени (системы, в которых у задач есть сроки, к которым они должны быть выполнены)
Сами системы делятся на:
* Жёсткие (нельзя нарушать ни один срок)
* Гибкие (нежелательно, но можно)

События в них делятся на:
* Периодические
* Апериодические

Чтобы система была **планируемой** (хз, чё это, видимо какое-то хорошее качество), должно выполняться неравенство: `A1/B1 + A2/B2 + ... + Am/Bm <= 1`, где `m` - количество событий, `A` - время обработки события, `B` - период возникновения события.

### Политика и механизмы
To be written
