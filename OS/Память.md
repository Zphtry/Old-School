**Иерархия памяти** - разделение памяти по скорости взаимодействия.  
**Диспетчер памяти** - управляет иерархией памяти  
# Без абстракций
Предоставление процессам полного доступа к памяти. Процессы могут запускаться только по одному. Более точно - в оперативной памяти может находиться только один процесс, остальные ждут на HDD.

# Абстракция памяти: адресные пространства
**Адресное пространство** - набор адресов, доступных процессу.

## Механизмы **выделения адресного пространства**:
* Базовый (начало адресного пространства) и ограничительный (его длина) регистры в **динамическом перераспределении** памяти. Эти регистры являются частью процессора. Если процесс хочет получить доступ к памяти, то проверяется лежит ли этот адрес в допустимых пределах (базовый; базовый + ограничительный). Для **процесса** начало АП это `0`, а для **аппаратуры** это базовый. Недостаток - сложение, необходимое для вычисления конца АП, 'дорогая' операция.
* **Свопинг** - размещение процесса целиком, если что сброс на HDD и обратно. Также процессы могут потребовать дополнительной памяти (**динамический режим распределения памяти**), тогда если за ним есть свободное место, ему её выделяют, если нет, то мешающий процесс может быть скинут на HDD или перемещён внутри памяти. Если и этой памяти не хватило, то процесс ждёт.
* Виртуальная память

## Динамический режим распределения памяти:
* **Битовая матрица**. Память разбивается на __блоки__ (размером от нескольких слов до нескольких килобайт). Заводится матрица, содержащая информацию о том, свободны блоки или нет. Важно грамотно выбрать размер блока.
* **Связанные списки**, содержащие информацию о сегменте:

 Структура `ABCD`, где `A` - маркер, обозначающий, что это за сегмент(P - process, H - hole), B - начало    сегмента, `С` - его длина, `D` - ссылка на следующую запись списка.

  ![](https://pp.vk.me/c639223/v639223501/e57/NvX_4NkSWF0.jpg)  
 Возможно расширение до двусвязного списка, чтобы была ссылка и на **предыдущий** элемент.

## Алгоритмы помещения нового процесса в память (списки):
* **Первое подходящее** по размеру пространство
* **Следующее подходящее** по размеру пространство, оставшееся от последнего поиска
* **Наиболее подходящее** - минимальный подходящий размер
* **Наименее подходящее** - максимальный подходящий размер

Также есть вариант вести отдельные списки для **процессов** и **пустых мест**
* Быстро искомое - когда дополнительно ведётся список **пустых мест** для некоторых самых **популярных адресов**.

# Виртуальная память
## Общие сведения
Адресное пространство программы разбивается на **страницы**, - непрерывные диапазоны адресов.  
Программным образом генерируются адреса, образующие **виртуальное адресное пространство**, которое по размерам может превышать **физическое**. Диспетчер памяти отображает **виртуальное** в **физическое** и хранит в себе это **отображение**. **Виртуальное** и **физическое** разбиваются на **страницы** (естественно без остатка). Часть страниц представлена на физическом уровне, часть - нет. Если программа обращается к странице, отображённой на физ. уровне, то она просто получает нужную информацию. Если к неотображённой, то эта страница отображается в физ. память, какая-то страница из физ. выкидывается, и отображение перестраивается. За существование на физическом уровне отвечает **бит присутствия**.   
![](https://pp.vk.me/c639223/v639223501/e77/x78foipQEZQ.jpg)

## Структура одной записи в таблице страниц
Там много всякого шлака, кроме бита присутствия и номера стр. блока. Сам номер стр. блока состоит из страших битов (номер физической страницы) и младших (смещение, одинаковое для физ. и вирт.)

# Алгоритмы замещения страниц
При отсутствии вирт. страницы в физ. эта страница должна быть помещена туда, при этом должно приняться решение, какую выкинуть. Также надо проверить различаются ли копии выкидываемой страницы на физ. памяти и на диске. Если да, то страница с физ. памяти переписывает копию на диске, если нет то страница просто затирается новой. Важный вопрос - какие именно страницы выкидывать.

## Оптимальный алгоритм
Невозможный, но лучший. Суть в удалении страницы, которая понадобится через наибольшее количество операций. Невозможен потому что нельзя узнать, через сколько понадобится страница.

## Исключение недавно использовавшейся
Страницы делятся на 4 класса в зависимости от событий, происходивших с ними в последнее время:
0. Ни модификаций, ни обращений.  
1. Модификации без обращений.  
2. Обращения без модификаций.  
3. И обращения и модификации.  

Удаляется страница с самым низким классом
## FIFO
## Второй шанс
## Часы
## Наименее востребованная
